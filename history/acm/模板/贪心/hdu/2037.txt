今年暑假不AC

Time Limit:2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K(Java/Others)
Total Submission(s): 56235    Accepted Submission(s): 30245


Problem Description

“今年暑假不AC？”
“是的。”
“那你干什么呢？”
“看世界杯呀，笨蛋！”
“@#$%^&*%...”

确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。
作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）

 

 

Input

输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n<=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1<=i<=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。

 

 

Output

对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。

 

 

Sample Input

12

1 3

3 4

0 7

3 8

15 19

15 20

10 15

8 18

6 12

5 10

4 14

2 9

0

 

 

Sample Output

5

 

题目大意：有n个电视节目，给你他们的开始和结束时间，要求能够看可能多的电视节目，输出能够最多能看的电视节目数量。

 

题目分析：这是一道典型的贪心问题，由子问题最优推出该问题最优。那么容易想出集中贪心策略，最早开始时间，最短活动时间，最早结束时间。到底哪个是对的了，不防举一下反例，首先是最早开始时间，这显然是不对的，如（1,10），（2,3），（4，6），（7,11），显然最多电视节目的选择是（2,3），（4，6），（7,11）三个，而不是（1,10）一个，第二种贪心策略最短活动时间，看似是正确的，但是仔细推敲一下会发现也是不对的，如（1,5），（4,7），（6,10）时，该贪心策略就不对了，最后一种最早结束时间看似不对，其实是对的。假设由该贪心策略排列出的最佳方案是a1，a2…ak，如果不是的话，则可以在加一个电视节目进去，假设是加在an-1与an+1之间（n+1<=k），如果该节目是b，则b的结束时间有三种可能，在an的开始时间之前，an的开始时间与结束时间之间，an的结束时间之后，但是这三种与该贪心策略不符合（因为该贪心策略是有结束时间排序的），所以可以排除。

 

代码：

[cpp] view plain copy
<span style="font-family:Microsoft YaHei;font-size:18px;">#include<iostream>  
#include<algorithm>  
   
usingnamespacestd;  
#definesize500  
   
structstrc  
{  
      intstart, stop;  
} str[size];  
   
bool cmp(strca,strcb)  
{  
      returna.stop<b.stop;  
}  
   
int main()  
{  
      intt;  
      while(cin >> t)  
      {  
          if(t>0)  
           {  
                inttimes = 1;  
                for(int i = 0; i<t; i++)         //输入节目的开始时间和结束时间,存在结构体中。  
                 {  
                      cin>> str[i].start >> str[i].stop;  
                 }  
                 sort(str,str + t, cmp);           //按结束时间排序  
                for(int i = 1, j = 0; i<t; i++)  
                 {  
                     if(str[i].start >= str[j].stop)  
                      {  
                            times++;               //如果该节目的开始时间不小于上一个节目的结束时间,则加一  
                            j= i;  
                      }  
                 }  
                 cout<< times << endl;  
           }  
      }  
      return0;  
}  
 </span> 