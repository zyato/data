## 1. String 不可变有什么好处

1. 这样可以解决同步安全问题。
    - 因为字符串是不可变的，所以是多线程安全的，同一个字符串实例可以被多个线程共享。这样便不用因为线程安全问题而使用同步。字符串自己便是线程安全的。

2. 设计成不可变的就会导致性能下降，因为每次修改都将产生新的对象，而字符串缓冲池很好的解决了这个问题。

3. 安全，因为很多操作都是以字符串作为参数的（数据库的用户名、密码都是以字符串的形式传入来获得数据库的连接；或者在socket编程中，主机名和端口都是以字符串的形式传入），字符串如果可以修改，那么在我们操作的过程中如果有人对字符串进行了修改，那么我们将得不到正确的结果甚至引起很严重的安全问题。
4. 可以加快字符串处理速度。因为字符串是不可变的，所以在它创建的时候 hashcode 就被缓存了，不需要重新计算。这就使得字符串很适合作为 Map 中的键，字符串的处理速度要快过其它的键对象。这就是 HashMap 中的键往往都使用字符串。

## 2. notify 产生死锁的场景（生产者消费者模式）

生产者、消费者数量都为 2，缓冲区为 1，当按照下列并发顺序执行的时候出现死锁：

1. 消费者 1 获得锁，发现缓冲区为 0，wait（wait 自动释放锁）；

2. 消费者 2 获得锁，发现缓冲区为 0，wait（wait 自动释放锁）；

3. 生产者 1 获得锁，发现缓冲区为 0 可以生产，生产以后放在缓冲区，notify，现在缓冲区为 1；

4. 第 3 步 notify 唤醒了消费者 1，但是消费者 1 没有抢到锁，锁被生产者 2 拿到了；

5. 生产者 2 发现缓冲区为 1（因为只是唤醒了消费者 1，但是消费者 1 没有抢到锁，没法消费），wait（wait 自动释放锁）；

6. 现在消费者 1 获得了锁，消费并且 notify（此时生产者 2 和消费者 2 都处于 wait 状态），缓冲区为 0；

7. 很不幸，第 6 步 notify 唤醒了消费者 2，消费者 2 醒来后拿到锁发现缓冲区为 0 ，接着 wait，与此同时，生产者 2 也在 wait，死锁产生。

可以看出问题的关键在于两个地方，一个是第 4 步 notify 并不能保证 notify 唤醒的线程获得锁，一个是第 7 步 notify 可能会唤醒同一种角色的线程。

可以用 Lock/Condition 解决，两个 Condition 可以保证 notify（signal）不同角色的线程，也可以用 notifyAll 解决，使线程间变成对锁的竞争。

## 3. mysql 分页查询

### 3.1 mysql 分页查询的实现

1. 数据量较小的情况：```select * from table limit (pageNo-1) * pageSize, pageSize;```
2. 数据量较大的情况（要求 good_id 的数据连续，条件一般很难满足）：
    - 假设主键或者唯一索引为 good_id
    - 收到客户端 { pageNo:5, pagesize:10 }
    - ```select * from table where good_id > (pageNo-1) * pageSize limit pageSize;```
    - 返回 good_id 为 40 到 50 之间的数据

### 3.2 对于 limit 10000, 100000000000000 查询缓慢的解决办法

1.  limit 10000,20 的意思扫描满足条件的 10020 行，扔掉前面的 10000 行，返回最后的 20 行，问题就在这里。

2. 如果我们之前记录了最大 ID，就可以在这里做文章

3. 日常分页 SQL 语句

    - select id,name,content from users order by id asc limit 100000,20；扫描100020行

    - 如果记录了上次的最大 ID

        select id,name,content from users where id>100073 order by id asc limit 20；扫描20行

    - 总数据有 500 万左右

4. 如果查询的记录比较大，并且数据传输量比较大，比如包含了 text 类型的 field，则可以通过建立子查询。

    ```SELECT id, title, content FROM items WHERE id IN (SELECT id FROM items ORDER BY id limit 900000, 10);```

### 3.3 反向查找优化法

- 当偏移超过一半记录数的时候，先用排序，这样偏移就反转了

- 缺点：order by 优化比较麻烦，要增加索引，索引影响数据的修改效率，并且要知道总记录数，偏移大于数据的一半

- 举例：

    ```mysql
       -- 第30000页
       -- 正向查找SQL:
       -- Sql代码
       SELECT * FROM `abc` WHERE `BatchID` = 123 LIMIT 1199960, 40
       时间：2.6493 秒
       -- 反向查找sql:
       -- Sql代码
       SELECT * FROM `abc` WHERE `BatchID` = 123 ORDER BY InputDate DESC LIMIT 428775, 40
        时间：1.0035 秒
       -- 注意，反向查找的结果是是降序 desc 的，并且 InputDate 是记录的插入时间，也可以用主键联合索引，但是不方便。
    ```

## 4. 

1.公司培训制度是怎样的

2.针对公司业务学习的侧重点有哪些

1.部门业务是什么

2.所用技术栈是什么


